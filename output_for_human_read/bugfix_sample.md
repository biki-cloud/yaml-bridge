# ログイン時のセッション重複バグ修正

**タイプ:** 🐛 バグ修正 | **ステータス:** 🔵 Draft | **バージョン:** 1.0.0
**作成者:** 開発チーム | **作成日:** 2026-01-29 | **更新日:** 2026-01-29

---

## 背景・目的

**目的:** ログイン時に古いセッションが残り続けるバグを修正する

### 背景

本番環境で複数のユーザーから「ログアウトしたはずなのに
別のデバイスでログイン状態が維持されている」という報告が
上がっている。セキュリティ上の問題となる可能性がある。

### 関連リンク

- https://github.com/example/issues/999
- https://support.example.com/tickets/12345

## 症状

**説明:** ログアウト後も別デバイスでセッションが有効なまま残る

**発生頻度:** 頻繁 | **影響度:** 🟠 重大

**影響範囲:** 全ユーザー（特に複数デバイス利用者）

### 再現手順

1. デバイスAでログインする
2. デバイスBでログインする
3. デバイスAでログアウトする
4. デバイスBでページをリロードする
5. デバイスBでまだログイン状態であることを確認

### 期待動作 vs 実際の動作

**期待:** デバイスAでログアウトしたら、全デバイスでログアウトされる

**実際:** デバイスAでログアウトしても、デバイスBではログイン状態が継続する

### エラーログ

```
[WARN] Session cleanup incomplete: user_id=12345, 
remaining_sessions=2, expected=0
[ERROR] Redis SCAN timeout after 5000ms

```

## 根本原因

**原因:** ログアウト処理でセッション削除にRedisのDELコマンドを使用しているが、
ユーザーの全セッションを取得するSCANがタイムアウトし、
一部のセッションが削除されずに残っている。


**問題箇所:**

- ファイル: `src/services/auth/session.ts`
- 行: 145
- 関数: `clearUserSessions`

### なぜなぜ分析

**Why 1:** なぜセッションが残るのか？
→ SCANコマンドがタイムアウトして全セッションを取得できていない

**Why 2:** なぜSCANがタイムアウトするのか？
→ セッションキーが多すぎてスキャンに時間がかかる

**Why 3:** なぜセッションキーが多いのか？
→ 有効期限切れのセッションが削除されずに蓄積している

**Why 4:** なぜ有効期限切れセッションが削除されないのか？
→ RedisのTTL設定が漏れているセッションがある

**Why 5:** なぜTTL設定が漏れるのか？
→ セッション作成時のTTL設定が条件分岐で一部スキップされている

**混入元:** PR

## 修正内容

**アプローチ:** 1. セッション作成時に必ずTTLを設定するよう修正
2. ログアウト時のセッション削除をバッチ処理に変更
3. 既存の孤立セッションをクリーンアップするバッチを実行


### 変更ファイル

#### `src/services/auth/session.ts`

セッション作成時のTTL設定漏れを修正

**Before:**
```
if (rememberMe) {
  await redis.set(sessionKey, sessionData);
  await redis.expire(sessionKey, LONG_TTL);
} else {
  await redis.set(sessionKey, sessionData);
}

```

**After:**
```
const ttl = rememberMe ? LONG_TTL : SHORT_TTL;
await redis.set(sessionKey, sessionData, 'EX', ttl);

```

#### `src/services/auth/session.ts`

ログアウト時の削除処理をパイプラインで実行

**Before:**
```
const keys = await scanAllKeys(`session:${userId}:*`);
for (const key of keys) {
  await redis.del(key);
}

```

**After:**
```
const keys = await scanAllKeys(`session:${userId}:*`);
if (keys.length > 0) {
  const pipeline = redis.pipeline();
  keys.forEach(key => pipeline.del(key));
  await pipeline.exec();
}

```

### 想定される副作用

- ⚠️ 既存の長期セッションが次回アクセス時に期限切れになる可能性
- ⚠️ ログアウト処理が若干高速化する

## 検証計画

### テストケース

**TC-1:** 複数デバイスログイン時の一括ログアウト

  1. デバイスAでログインする
  2. デバイスBでログインする
  3. デバイスAでログアウトする
  4. デバイスBでページをリロードする

  **期待結果:** デバイスBでもログアウト状態になっている

**TC-2:** セッションTTLの設定確認

  1. ログインする（remember meなし）
  2. RedisでセッションキーのTTLを確認する

  **期待結果:** TTLが設定されている（SHORT_TTL）

**TC-3:** remember me有効時のTTL確認

  1. ログインする（remember meあり）
  2. RedisでセッションキーのTTLを確認する

  **期待結果:** TTLが設定されている（LONG_TTL）

### 検証環境

- ステージング環境
- 本番環境（カナリアリリース）

## 再発防止策

### 即時対応

- [ ] 本修正のデプロイ
- [ ] 孤立セッションのクリーンアップバッチ実行

### 長期対応

- [ ] Redisセッション数のモニタリングアラート追加
- [ ] セッション作成のユニットテスト強化
- [ ] コードレビューチェックリストに「TTL設定」を追加

## リスクと対策

| リスク | 深刻度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| 修正デプロイ時にログイン中ユーザーが強制ログアウトされる | 🟡 中 | low | ローリングデプロイで段階的に適用 |
| クリーンアップバッチによるRedis負荷増大 | 🟡 中 | medium | 深夜帯に実行し、処理を分割して実行 |

## テスト計画

### ユニットテスト

- [ ] セッション作成時のTTL設定
- [ ] パイプラインによる一括削除

### 結合テスト

- [ ] マルチデバイスでのログイン/ログアウトフロー
- [ ] セッション有効期限の動作確認

### 回帰テスト

- [ ] 通常のログイン/ログアウトフロー
- [ ] remember me機能
