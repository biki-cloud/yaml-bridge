# yaml-language-server: $schema=../schemas/bugfix.schema.json
# AI作成用YAML - このファイルをAIが編集します

meta:
  title: ログイン時のセッション重複バグ修正
  type: bugfix
  version: 1.0.0
  status: draft
  author: 開発チーム
  created_at: "2026-01-29"
  updated_at: "2026-01-29"

background:
  purpose: ログイン時に古いセッションが残り続けるバグを修正する
  context: |
    本番環境で複数のユーザーから「ログアウトしたはずなのに
    別のデバイスでログイン状態が維持されている」という報告が
    上がっている。セキュリティ上の問題となる可能性がある。
  issue_links:
    - https://github.com/example/issues/999
    - https://support.example.com/tickets/12345

symptom:
  description: ログアウト後も別デバイスでセッションが有効なまま残る
  frequency: often
  impact: major
  affected_users: 全ユーザー（特に複数デバイス利用者）
  reproduction_steps:
    - デバイスAでログインする
    - デバイスBでログインする
    - デバイスAでログアウトする
    - デバイスBでページをリロードする
    - デバイスBでまだログイン状態であることを確認
  expected_behavior: デバイスAでログアウトしたら、全デバイスでログアウトされる
  actual_behavior: デバイスAでログアウトしても、デバイスBではログイン状態が継続する
  error_logs: |
    [WARN] Session cleanup incomplete: user_id=12345, 
    remaining_sessions=2, expected=0
    [ERROR] Redis SCAN timeout after 5000ms

root_cause:
  description: |
    ログアウト処理でセッション削除にRedisのDELコマンドを使用しているが、
    ユーザーの全セッションを取得するSCANがタイムアウトし、
    一部のセッションが削除されずに残っている。
  location:
    file: src/services/auth/session.ts
    line: 145
    function: clearUserSessions
  why_analysis:
    - why: なぜセッションが残るのか？
      answer: SCANコマンドがタイムアウトして全セッションを取得できていない
    - why: なぜSCANがタイムアウトするのか？
      answer: セッションキーが多すぎてスキャンに時間がかかる
    - why: なぜセッションキーが多いのか？
      answer: 有効期限切れのセッションが削除されずに蓄積している
    - why: なぜ有効期限切れセッションが削除されないのか？
      answer: RedisのTTL設定が漏れているセッションがある
    - why: なぜTTL設定が漏れるのか？
      answer: セッション作成時のTTL設定が条件分岐で一部スキップされている
  introduced_by: PR #456 (2025-11-15) - セッション管理のリファクタリング

fix:
  approach: |
    1. セッション作成時に必ずTTLを設定するよう修正
    2. ログアウト時のセッション削除をバッチ処理に変更
    3. 既存の孤立セッションをクリーンアップするバッチを実行
  changes:
    - file: src/services/auth/session.ts
      description: セッション作成時のTTL設定漏れを修正
      before: |
        if (rememberMe) {
          await redis.set(sessionKey, sessionData);
          await redis.expire(sessionKey, LONG_TTL);
        } else {
          await redis.set(sessionKey, sessionData);
        }
      after: |
        const ttl = rememberMe ? LONG_TTL : SHORT_TTL;
        await redis.set(sessionKey, sessionData, 'EX', ttl);
    - file: src/services/auth/session.ts
      description: ログアウト時の削除処理をパイプラインで実行
      before: |
        const keys = await scanAllKeys(`session:${userId}:*`);
        for (const key of keys) {
          await redis.del(key);
        }
      after: |
        const keys = await scanAllKeys(`session:${userId}:*`);
        if (keys.length > 0) {
          const pipeline = redis.pipeline();
          keys.forEach(key => pipeline.del(key));
          await pipeline.exec();
        }
  side_effects:
    - 既存の長期セッションが次回アクセス時に期限切れになる可能性
    - ログアウト処理が若干高速化する

verification:
  test_cases:
    - description: 複数デバイスログイン時の一括ログアウト
      steps:
        - デバイスAでログインする
        - デバイスBでログインする
        - デバイスAでログアウトする
        - デバイスBでページをリロードする
      expected_result: デバイスBでもログアウト状態になっている
    - description: セッションTTLの設定確認
      steps:
        - ログインする（remember meなし）
        - RedisでセッションキーのTTLを確認する
      expected_result: TTLが設定されている（SHORT_TTL）
    - description: remember me有効時のTTL確認
      steps:
        - ログインする（remember meあり）
        - RedisでセッションキーのTTLを確認する
      expected_result: TTLが設定されている（LONG_TTL）
  regression_scope:
    - ログイン機能
    - ログアウト機能
    - セッション管理全般
  environments:
    - ステージング環境
    - 本番環境（カナリアリリース）

prevention:
  immediate_actions:
    - 本修正のデプロイ
    - 孤立セッションのクリーンアップバッチ実行
  long_term_actions:
    - Redisセッション数のモニタリングアラート追加
    - セッション作成のユニットテスト強化
    - コードレビューチェックリストに「TTL設定」を追加

risks:
  - risk: 修正デプロイ時にログイン中ユーザーが強制ログアウトされる
    severity: medium
    probability: low
    mitigation: ローリングデプロイで段階的に適用

  - risk: クリーンアップバッチによるRedis負荷増大
    severity: medium
    probability: medium
    mitigation: 深夜帯に実行し、処理を分割して実行

testing:
  unit_tests:
    - セッション作成時のTTL設定
    - パイプラインによる一括削除
  integration_tests:
    - マルチデバイスでのログイン/ログアウトフロー
    - セッション有効期限の動作確認
  regression_tests:
    - 通常のログイン/ログアウトフロー
    - remember me機能
